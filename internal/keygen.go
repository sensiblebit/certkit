package internal

import (
	"crypto"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"

	"github.com/sensiblebit/certkit"
)

// KeygenOptions holds parameters for key and CSR generation.
type KeygenOptions struct {
	Algorithm string
	Bits      int
	Curve     string
	OutPath   string
	CN        string
	SANs      []string
}

// KeygenResult holds the paths of files generated by GenerateKeyFiles.
type KeygenResult struct {
	KeyFile string
	PubFile string
	CSRFile string // empty if no CSR generated
}

// GenerateKey creates a new crypto.Signer based on algorithm, bits, and curve.
func GenerateKey(algorithm string, bits int, curve string) (crypto.Signer, error) {
	switch algorithm {
	case "rsa":
		return certkit.GenerateRSAKey(bits)
	case "ecdsa":
		c, err := parseCurve(curve)
		if err != nil {
			return nil, err
		}
		return certkit.GenerateECKey(c)
	case "ed25519":
		_, priv, err := certkit.GenerateEd25519Key()
		if err != nil {
			return nil, err
		}
		return priv, nil
	default:
		return nil, fmt.Errorf("unsupported algorithm: %s (use rsa, ecdsa, or ed25519)", algorithm)
	}
}

// GenerateKeyFiles generates a key pair and optionally a CSR, writing them to the output path.
func GenerateKeyFiles(opts KeygenOptions) (*KeygenResult, error) {
	signer, err := GenerateKey(opts.Algorithm, opts.Bits, opts.Curve)
	if err != nil {
		return nil, err
	}

	// Marshal private key
	keyPEM, err := certkit.MarshalPrivateKeyToPEM(signer)
	if err != nil {
		return nil, fmt.Errorf("marshaling private key: %w", err)
	}

	// Marshal public key
	pubPEM, err := certkit.MarshalPublicKeyToPEM(signer.Public())
	if err != nil {
		return nil, fmt.Errorf("marshaling public key: %w", err)
	}

	// Write files
	if err := os.MkdirAll(opts.OutPath, 0755); err != nil {
		return nil, fmt.Errorf("creating output directory: %w", err)
	}

	result := &KeygenResult{
		KeyFile: filepath.Join(opts.OutPath, "key.pem"),
		PubFile: filepath.Join(opts.OutPath, "pub.pem"),
	}

	if err := os.WriteFile(result.KeyFile, []byte(keyPEM), 0600); err != nil {
		return nil, fmt.Errorf("writing private key: %w", err)
	}

	if err := os.WriteFile(result.PubFile, []byte(pubPEM), 0644); err != nil {
		return nil, fmt.Errorf("writing public key: %w", err)
	}

	// Generate CSR if CN or SANs provided
	if opts.CN != "" || len(opts.SANs) > 0 {
		csrPEM, err := generateCSRFromKey(signer, opts.CN, opts.SANs)
		if err != nil {
			return nil, fmt.Errorf("generating CSR: %w", err)
		}
		result.CSRFile = filepath.Join(opts.OutPath, "csr.pem")
		if err := os.WriteFile(result.CSRFile, []byte(csrPEM), 0644); err != nil {
			return nil, fmt.Errorf("writing CSR: %w", err)
		}
	}

	return result, nil
}

func generateCSRFromKey(signer crypto.Signer, cn string, sans []string) (string, error) {
	template := &x509.CertificateRequest{
		Subject: pkix.Name{
			CommonName: cn,
		},
		DNSNames: sans,
	}

	csrDER, err := x509.CreateCertificateRequest(rand.Reader, template, signer)
	if err != nil {
		return "", fmt.Errorf("creating CSR: %w", err)
	}

	csrPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE REQUEST",
		Bytes: csrDER,
	})

	return string(csrPEM), nil
}

func parseCurve(name string) (elliptic.Curve, error) {
	switch name {
	case "P-256", "p256", "prime256v1":
		return elliptic.P256(), nil
	case "P-384", "p384", "secp384r1":
		return elliptic.P384(), nil
	case "P-521", "p521", "secp521r1":
		return elliptic.P521(), nil
	default:
		return nil, fmt.Errorf("unsupported curve: %s (use P-256, P-384, or P-521)", name)
	}
}
